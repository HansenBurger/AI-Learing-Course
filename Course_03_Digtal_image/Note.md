# course 3 数字图像处理

## 一、图像

### 1.1 像素

像素为分辨率的单位，像素是构成位图图像的基本单元，每个像素都有自己颜色

### 1.2 分辨率

1. 分辨率是单位英寸内的像素点数，单位为PPI
2. PII表示每英寸对角线上有的像素数: PPI = 根号X^2 + Y^2 / Z
3. 屏幕尺寸: 对角线长度
4. 被错误用作衡量图像内像素点的数量

分辨率是一个密度单位

### 1.3 RGB

色彩三原色(CMYK): 品红、黄、青蓝

光学三原色(RGB): 红，绿，蓝

RGB颜色模型就是三维直角坐标系颜色系统中一个单位正方体

对角线上，各原色量相等，产生暗到亮的白色，即灰度

黑(0,0,0), 白(255,255,255)

### 1.4 灰度

灰度: 图像明暗程度的数值，0-255，白255，黑0

### 1.5 通道

1. 单通道: 一个像素一个数值，只能表示灰度(二值图&灰度图)
2. 三通道: RGB，图像分为红绿蓝三个通道，表示彩色
3. 四通道: RGBA，加入alpha表示透明度，alpha=0全透明 (与底色和多多层和合成有关,png)

一个通道表示一组数据(多张纸叠加)

### 1.6 对比度

不同颜色之间的差别。对比度=最大灰度值/最小灰度值

### 1.7 RGB转Gray

三通道转单通道:

1. 浮点算法: Gray=R0.3 + G0.59 + B0.11 (肉眼对绿色更加敏感，实验得到的比例)
2. 整数方法: Gray=(R30+G59+B11)/100
3. 移位方法: Gray=(R76+G151+B*28) >> 8
4. 平均值法: Gray=(R+G+B) / 3
5. 仅取绿色: Gray=G

图像识别将彩色图像灰度化的原因:

1. 减少计算量
2. 图像识别的场景不需要颜色识别

### 1.8 RGB转浮点数

/255 转化为范围为0到1的浮点数

二值化: 把像素根据条件分为0,1

opencv 对于读取进来的图片的通道排列是**BGR**, 而不是主流RGB

```python
img4 = cv2.imread('1.jpg')
img4 = cv2.cvtColor(img4,cv2.COLOR_BGR2RGB)
```

### 1.9 频率 幅值

频率: 灰度值变化的剧烈程度，灰度在平面空间上的梯度

幅值: 见图(转f)

## 二、图像的取样和量化

取样: 用多少点来描述一幅图像，取样结果质量的高低用图像分辨率衡量 (**数字化坐标值**)

量化: 用多大的范围数值来表示图像采样后的点 (**数字化幅度值**)

取样后像素数: M*N

## 三、上采样与下采样

### 3.1 定义

缩小图像(下采样_subsampled, 降采样_downsampled) ,

上采样原理: 内插值

下采样原理: 插值 or (M/s) * (N/s)

### 3.2 常见插值方法

1.最邻近插值

填充像素所在区域和最近的像素的值(灰度, 通道)一致

```python
def function(img):
    height,width,channels =img.shape
    emptyImage=np.zeros((800,800,channels),np.uint8)
    sh=800/height   #缩放的比例
    sw=800/width
    for i in range(800):
        for j in range(800):
            x=int(i/sh) #取整来看插入像素和原图的像素一致
            y=int(j/sw)
            emptyImage[i,j]=img[x,y]
    return emptyImage
```

图像放大成800*800的比例(python向下取整)

目标: 计算放大后未知的像素值

插值改变了像素点的个数而不是单纯的放大

python3.7 conda opencv
conda install -c conda-forge opencv

## 八、直方图

### 8.1 定义

颜色直方图，灰度直方图

灰度直方图: 描述了图像中灰度的分布情况，直观的展示出图像中各个灰度级所占的个数

横坐标: 灰度级, 纵坐标: 灰度级出现频率

### 8.2 性质

描述了**每个灰度级的分布**

> 图像直方图不关心像素所处的空间位置，因此不受图像旋转和平移变化的影响，可以作为图像的特征

任何一幅特定的图像都有唯一直方图对应，不同的图像可能有同样的直方图

整幅图像的直方图，为两个不相连区域的直方图之和

### 8.3 应用

反应明暗的分布(而非异常)

可以通过观察直方图来看图像是否符合预期

多通道(每个通道各统计一个直方图)

(mask: 掩膜, 覆盖图像)

### 8.4 直方图均衡化

直方图均衡化就是使用一定算法使直方图**大致平和**的方法

> 直方图均衡化的作用是图像增强

均衡流程:

1. 需要一个映射函数，原像素值映射到新直方图:
    con1. 映射后亮暗大小关系不变
    con2. 映射后必须在原有范围内

2. 计算原始灰度直方图H

3. 计算灰度直方图的累加直方图

4. 根据累加直方图和直方图均衡化原理得到输入与输出之间的**映射关系**

5. dst(x,y) = H'(src(x,y))

均衡化后: 对比度更高

### 8.5 公式推导

1.对输入图像像素p找到对应的输出图像像素q(**输入和输出像素总量相等**)

累加直方图公式(左右像素灰度总量相等):

$$
\begin{equation}
\sum_{k=0}^phist_{input}(k)=\sum_{k=0}^qhist_{iout}(k)
\end{equation}
$$

其中 $p\in[0,255]$, $q\in[0,255]$, hist是对应灰度下像素的个数的分布函数

> **备注:**
    我的理解，直方图均衡化是在找每个像素灰度对应的映射。即，对于灰度p，从0到p在灰度直方图上的累计面积应该和S相同，在像素个数和灰度已知的情况下，就可以求出p对应的q。又因为整体上$hist_{out}$可以视作定值，就有后续的公式带入。

![hist_graph_explaination](https://pic1.imgdb.cn/item/6334397416f2c2beb14ed743.png)

2.其中，**输出**图像每个灰度级的个数(像素平均分布到每个灰度上):

$$
\begin{equation}
hist_{out}(k) \approx \frac{H\times W}{256},k\in[0,255]
\end{equation}
$$

3.代入累加直方图公式:

$$
\begin{equation}
\sum_{k=0}^phist_{input}(k)\approx(q+1)\frac{H\times W}{256},k\in[0,255]
\end{equation}
$$

可以得到q

$$
\begin{equation}
q\approx \frac{\sum_{k=0}^phist_{input}(k)}{H\times W}\times 256  -1 ,k\in[0,255]
\end{equation}
$$

### 8.6 流程推导(表)

将偏暗的灰度图转换成在灰度上均匀的图

![hist_euqalization_table](https://pic1.imgdb.cn/item/6334397416f2c2beb14ed740.png)

### 8.7 直方图均衡后出现过白情况

出现直方图均衡后整体偏白：**原始图的0像素值过多**，累加过程中导致1-255的像素的映射值都被放大了

处理方法：避开0像素值，从1像素值开始累加计算

## 九、滤波

线性滤波可以说是图像处理最基本的方法，它可以允许我们对图像进行处理，产生不同的效果

九个数对应相乘，求和，得到中心位置的结果(**加权求和**)

窗口滑动(根据**步长**滑动)

周围一圈: 填充0 padding

## 十、卷积

计算前翻转180°, 做乘积(行(窗)*列(卷积核))

**滤波到卷积的卷积核, 需要反转。**

滤波器:
    1. 大小为奇数，有一个中心，也有半径(5*5, r=2)
    2. 滤波器矩阵所有元素之和应该要等于1， 为了保证前后亮度不变(非强制)
    3. 滤波器所有元素之和>1:更亮，<1: 更暗, =0: 非常暗
    4. 滤波后的结果不需要拿来视作图像，如果要输出图像，需要做截断，如出现负值(取绝对值)

具体应用会有多个卷积核，每一个卷积核表示图像模式

[[1 0 -1]
[1 0 -1]
[1 0 -1]]

边缘检测(竖着)

找灰度变化的地方, 用来区分个体

输入 + 卷积核 = 预期特征

> 卷积负责提取图像中的局部特征

(图像ID：哈希)

卷积操作不可逆

### 10.1 步长(stride)

问题:
    1. f/s > 1, 原始图像变小
    2. 丢失信息

### 10.2 填充(pading)

(见笔记)

### 10.3 三种填充模式

full(): 相交就卷积

same(): 正常情况，中心重合开始卷积

valid(): 全进入才卷积

same 不代表输入输出尺寸一样, 和步长相关, same最常见, 可以卷积过程中让图大小不变

### 10.4 3通道卷积

输入多通道, 卷积核多通道, 一个权值有多个通道, 通道数相等

1. 权值(卷积核)个数 = **需要提取特征的数量** 权值C=输入C

2. 输出的通道数 = 权值的个数 = **提取特征的种类**
(相当于 y0 = w0x + b0, y1 = w1x + b1)

偏置b的意义: 添加截距, 神经网络

输入和输出的通道数无关

CNN: 过滤器的特征不是人为设定，而是通过大量图片自己训练的

(上一卷积的输出可以做下一卷积的输入, 所以输入输出通道数没有限制)
