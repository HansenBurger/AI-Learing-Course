# course 3 数字图像处理

## 一、图像

### 1.1 像素

像素为分辨率的单位，像素是构成位图图像的基本单元，每个像素都有自己颜色

### 1.2 分辨率

1. 分辨率是单位英寸内的像素点数，单位为PPI
2. PII表示每英寸对角线上有的像素数: PPI = 根号X^2 + Y^2 / Z
3. 屏幕尺寸: 对角线长度
4. 被错误用作衡量图像内像素点的数量

分辨率是一个密度单位

### 1.3 RGB

色彩三原色(CMYK): 品红、黄、青蓝

光学三原色(RGB): 红，绿，蓝

RGB颜色模型就是三维直角坐标系颜色系统中一个单位正方体

对角线上，各原色量相等，产生暗到亮的白色，即灰度

黑(0,0,0), 白(255,255,255)

### 1.4 灰度

灰度: 图像明暗程度的数值，0-255，白255，黑0

### 1.5 通道

1. 单通道: 一个像素一个数值，只能表示灰度(二值图&灰度图)
2. 三通道: RGB，图像分为红绿蓝三个通道，表示彩色
3. 四通道: RGBA，加入alpha表示透明度，alpha=0全透明 (与底色和多多层和合成有关,png)

一个通道表示一组数据(多张纸叠加)

### 1.6 对比度

不同颜色之间的差别。对比度=最大灰度值/最小灰度值

### 1.7 RGB转Gray

三通道转单通道:

1. 浮点算法: Gray=R0.3 + G0.59 + B0.11 (肉眼对绿色更加敏感，实验得到的比例)
2. 整数方法: Gray=(R30+G59+B11)/100
3. 移位方法: Gray=(R76+G151+B*28) >> 8
4. 平均值法: Gray=(R+G+B) / 3
5. 仅取绿色: Gray=G

图像识别将彩色图像灰度化的原因:

1. 减少计算量
2. 图像识别的场景不需要颜色识别

### 1.8 RGB转浮点数

/255 转化为范围为0到1的浮点数

二值化: 把像素根据条件分为0,1

opencv 对于读取进来的图片的通道排列是**BGR**, 而不是主流RGB

```python
img4 = cv2.imread('1.jpg')
img4 = cv2.cvtColor(img4,cv2.COLOR_BGR2RGB)
```

### 1.9 频率 幅值

频率: 灰度值变化的剧烈程度，灰度在平面空间上的梯度

幅值: 见图(转f)

## 二、图像的取样和量化

取样: 用多少点来描述一幅图像，取样结果质量的高低用图像分辨率衡量 (**数字化坐标值**)

量化: 用多大的范围数值来表示图像采样后的点 (**数字化幅度值**)

取样后像素数: M*N

## 三、上采样与下采样

### 3.1 定义

缩小图像(下采样_subsampled, 降采样_downsampled) ,

上采样原理: 内插值

下采样原理: 插值 or (M/s) * (N/s)

### 3.2 常见插值方法

1.最邻近插值

填充像素所在区域和最近的像素的值(灰度, 通道)一致

```python
def function(img):
    height,width,channels =img.shape
    emptyImage=np.zeros((800,800,channels),np.uint8)
    sh=800/height   #缩放的比例
    sw=800/width
    for i in range(800):
        for j in range(800):
            x=int(i/sh) #取整来看插入像素和原图的像素一致
            y=int(j/sw)
            emptyImage[i,j]=img[x,y]
    return emptyImage
```

图像放大成800*800的比例(python向下取整)

目标: 计算放大后未知的像素值

插值改变了像素点的个数而不是单纯的放大

python3.7 conda opencv
conda install -c conda-forge opencv

## 八、直方图

### 8.1 定义

颜色直方图，灰度直方图

灰度直方图: 描述了图像中灰度的分布情况，直观的展示出图像中各个灰度级所占的个数

横坐标: 灰度级, 纵坐标: 灰度级出现频率

### 8.2 性质

描述了**每个灰度级的分布**

> 图像直方图不关心像素所处的空间位置，因此不受图像旋转和平移变化的影响，可以作为图像的特征

任何一幅特定的图像都有唯一直方图对应，不同的图像可能有同样的直方图

整幅图像的直方图，为两个不相连区域的直方图之和

### 8.3 应用

反应明暗的分布(而非异常)

可以通过观察直方图来看图像是否符合预期

多通道(每个通道各统计一个直方图)

(mask: 掩膜, 覆盖图像)

### 8.4 直方图均衡化

直方图均衡化就是使用一定算法使直方图**大致平和**的方法

> 直方图均衡化的作用是图像增强

均衡流程:

1. 需要一个映射函数，原像素值映射到新直方图:
    con1. 映射后亮暗大小关系不变
    con2. 映射后必须在原有范围内

2. 计算原始灰度直方图H

3. 计算灰度直方图的累加直方图

4. 根据累加直方图和直方图均衡化原理得到输入与输出之间的**映射关系**

5. dst(x,y) = H'(src(x,y))

均衡化后: 对比度更高

### 8.5 公式推导

1.对输入图像像素p找到对应的输出图像像素q(**输入和输出像素总量相等**)

累加直方图公式(左右像素灰度总量相等):

$$
\begin{equation}
\sum_{k=0}^phist_{input}(k)=\sum_{k=0}^qhist_{iout}(k)
\end{equation}
$$

其中 $p\in[0,255]$, $q\in[0,255]$, hist是对应灰度下像素的个数的分布函数

> **备注:**
    我的理解，直方图均衡化是在找每个像素灰度对应的映射。即，对于灰度p，从0到p在灰度直方图上的累计面积应该和S相同，在像素个数和灰度已知的情况下，就可以求出p对应的q。又因为整体上$hist_{out}$可以视作定值，就有后续的公式带入。

![hist_graph_explaination](https://pic1.imgdb.cn/item/6334397416f2c2beb14ed743.png)

2.其中，**输出**图像每个灰度级的个数(像素平均分布到每个灰度上):

$$
\begin{equation}
hist_{out}(k) \approx \frac{H\times W}{256},k\in[0,255]
\end{equation}
$$

3.代入累加直方图公式:

$$
\begin{equation}
\sum_{k=0}^phist_{input}(k)\approx(q+1)\frac{H\times W}{256},k\in[0,255]
\end{equation}
$$

可以得到q

$$
\begin{equation}
q\approx \frac{\sum_{k=0}^phist_{input}(k)}{H\times W}\times 256  -1 ,k\in[0,255]
\end{equation}
$$

### 8.6 流程推导(表)

将偏暗的灰度图转换成在灰度上均匀的图

![hist_euqalization_table](https://pic1.imgdb.cn/item/6334397416f2c2beb14ed740.png)

### 8.7 直方图均衡后出现过白情况

出现直方图均衡后整体偏白：**原始图的0像素值过多**，累加过程中导致1-255的像素的映射值都被放大了

处理方法：避开0像素值，从1像素值开始累加计算

## 九、滤波

用**卷积**(数学方法)实现**滤波**(图像处理方法)

线性滤波可以说是图像处理最基本的方法，它可以允许我们对图像进行处理，产生不同的效果

![convolution_operation](https://img-blog.csdnimg.cn/img_convert/d6a377f9fab6532155d46a5ce76e80de.png)

卷积流程：

1. 九个数对应相乘，求和，得到中心位置的结果(**加权求和**)

2. 窗口滑动(根据**步长**滑动)

周围一圈: 填充 0 padding

## 十、卷积

计算前翻转180°, 做乘积(行(窗)*列(卷积核))

> 滤波到卷积的卷积核, 需要反转。但一般一开始设定的卷积核就是反转过的，不需要处理，除非两者需要转换

滤波器要求:

1. 大小为奇数，有一个中心，也有半径(5*5, r=2)
2. 滤波器矩阵所有元素之和应该要等于1， 为了保证前后亮度不变(非强制)
3. 滤波器所有元素之和>1:更亮，<1: 更暗, =0: 非常暗
4. 滤波后的结果不需要拿来视作图像，如果要输出图像，需要做**截断**，如出现负值(取绝对值)

具体应用会有多个卷积核，每一个卷积核表示图像模式 (找灰度变化的地方, 用来区分个体)

### 10.1 常用卷积核

1. 无效卷积核，像素值不变
$$
\begin{bmatrix}
   0 & 0 & 0 \\
   0 & 1 & 0 \\
   0 & 0 & 0
\end{bmatrix}
$$

2. 平滑均值卷积核，像素值=周围均值
$$
\begin{bmatrix}
   \frac{1}{9} & \frac{1}{9} & \frac{1}{9} \\
   \frac{1}{9} & \frac{1}{9} & \frac{1}{9} \\
   \frac{1}{9} & \frac{1}{9} & \frac{1}{9}
\end{bmatrix}
$$

3. 高斯平滑卷积核，平滑效果更好
$$
\begin{bmatrix}
   \frac{1}{16} & \frac{1}{8} & \frac{1}{16} \\
   \frac{1}{8} & \frac{1}{4} & \frac{1}{8} \\
   \frac{1}{16} & \frac{1}{8} & \frac{1}{16}
\end{bmatrix}
$$

4. 图像锐化卷积核，拉普拉斯核函数
$$
\begin{bmatrix}
   -1 & -1 & -1 \\
   -1 & 9 & -1 \\
   -1 & -1 & -1
\end{bmatrix}
\begin{bmatrix}
   0 & -1 & 0 \\
   -1 & 5 & -1 \\
   0 & -1 & 0
\end{bmatrix}
$$

5. Soble边缘检测(水平，垂直)
$$
\begin{bmatrix}
   -1 & 0 & 1 \\
   -2 & 0 & 2 \\
   -1 & 0 & 1
\end{bmatrix}
\begin{bmatrix}
   -1 & -2 & -1 \\
   0 & 0 & 0 \\
   1 & 2 & 1
\end{bmatrix}
$$

输入 + 卷积核 = 预期特征

> 总结：卷积负责提取图像中的局部特征

(图像ID：哈希)

卷积操作不可逆

### 10.2 步长(stride)

卷积核: $(f, f)$，图片: $(h, w)$，步长1得到图像大小: $(h-f+1, w-f+1)$ ，同理当步长为 $s$ 时的图像大小: $(\frac{h-f}{s}+1,\frac{w-f}{s}+1)$。

步长不为1且没有填充的卷积后尺寸的计算流程:
![size_calculation](https://pic1.imgdb.cn/item/633534e916f2c2beb121130c.png)

> **备注:** </br> 我的理解，卷积核只有中间的1*1像素的输出是保留的，因此计算大小的时候应该考虑的是**卷积核移动的距离**。同时，对于出现计算后有小数的情况，应该进行**向下取整**，保证像素作为最小单位的完整性。

问题:
    1. f或s只要大于1, 原始图像变小
    2. 会导致丢失信息

### 10.3 填充(padding)

假设填充的宽度为 $p$ ，填充后的大小: $(\frac{h-f+2p}{s}+1,\frac{w-f+2p}{s}+1)$

如果要让填充后大小不变：

$$
\begin{equation}
\frac{h-f+2p}{s}+1 = h
\end{equation}
$$

推导后可得：

$$
\begin{equation}
p = \frac{s(h-1)-h+f}{2}
\end{equation}
$$

当 $s$ 为1时，可以得到 $p$ 与 $f$ 的关系：

$$
\begin{equation}
p = \frac{f-1}{2}
\end{equation}
$$

三种填充模式：
![padding_way](https://pic1.imgdb.cn/item/63353bf916f2c2beb12823dc.png)

1. full()，相交就卷积
2. same()，正常情况，中心重合开始卷积
3. valid()，全进入才卷积(边缘不包含特征可以使用)

same 不代表输入输出尺寸一样, 和步长相关, same最常见, 可以卷积过程中让图大小不变

### 10.4 多通道卷积

输入多通道, 卷积核多通道, 一个权值有多个通道, 通道数相等

1. 权值(卷积核)个数 = **需要提取特征的数量** (权值C=输入C)

2. 输出的通道数 = 权值的个数 = **提取特征的种类**

多通道卷积流程(步长2):
![multiple_c_convolution](http://i.imgur.com/j8kLBKs.gif)

对于权值为 $w_0$，偏置为 $b_0$ 的卷积核，和权值为 $w_1$，偏置为 $b_1$ 的卷积核，输出为：

$$
\begin{equation}
\begin{aligned}
& y_0 = w_0 \times x + b_0 \\
& y_1 = w_1 \times x + b_1
\end{aligned}
\end{equation}
$$

偏置 $b$ 的意义: 添加截距, 具体应用于神经网络。

卷积的输入和输出的通道数无关。

CNN: 过滤器的特征不是人为设定，而是通过大量图片自己训练的

(上一卷积的输出可以做下一卷积的输入, 所以输入输出通道数没有限制)
